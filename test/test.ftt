
def Id (A : Type) (x y : A) : Type => (B : A -> Type) -> B x -> B y
def refl (A : Type) (x : A) : Id A x x => \B p => p

def Bool : Type => (A : Type) -> A -> A -> A
def tt : Bool => \A t f => t
def ff : Bool => \A t f => f

def Nat : Type => (A : Type) -> (A -> A) -> A -> A
def zero : Nat => \A s z => z
def suc (n : Nat) : Nat => \A s z => s (n A s z)


def not (x : Bool) : Bool => x Bool ff tt 

def test : Id Bool (not ff) tt => \B p => p

def test : Sub Bool tt => not ff



def + (n m : Nat) : Nat => n Nat suc m

def test : Sub Nat (+ (suc zero) (suc zero)) => suc (suc zero)

def x : Sub Bool tt => tt

def f (A : Type) (g : A -> A) : (x : A) -> Sub A (g x) => \x => g x

def test (A : Type) (x : A) (p : Sub A x) : Id A p x => \B p => p



def & (A B : Type) : Type => sig {fst : A ; snd : B}
def fst (A B : Type) (p : & A B) : A => p.fst
def snd (A B : Type) (p : & A B) : B => p.snd

def p : & Nat Bool => struct {fst => zero ; snd => tt}

def Sg (A : Type) (B : A -> Type) : Type => sig {fst : A ; snd : B fst}
def fst (A : Type) (B : A -> Type) (p : Sg A B) : A => p.fst
def snd (A : Type) (B : A -> Type) (p : Sg A B) : B (p.fst) => p.snd

def p : Sg Bool \b => Id Bool b tt => struct {fst => tt ; snd => \B p => p}


def Pt : Type => sig {type : Type ; pt : type}
def mkPt (A : Type) (x : A) : Pt => struct {type => A ; pt => x}

def id (x : Pt) : x.type => x.pt

def const (x : Pt) (y : sig {type : Sub Type x.type ; pt : type}) : x.type => x.pt

def Unit : Type => Sub Bool tt
def <> : Unit => tt
def Unit-eta (x : Unit) : Id Unit x <> => \B p => p
